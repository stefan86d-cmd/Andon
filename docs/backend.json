
{
  "rules": "rules_version = '2';\n\nservice cloud.firestore {\n  match /databases/{database}/documents {\n\n    // Helper function to check if a user has a specific role\n    function hasRole(role) {\n      return request.auth.token.role == role;\n    }\n\n    // Helper function to check if the user is the owner of a document\n    function isOwner(userId) {\n      return request.auth.uid == userId;\n    }\n\n    // Users collection\n    match /users/{userId} {\n      // Admins can read/write any user document\n      // Users can read/write their own document\n      allow read, write: if hasRole('admin') || isOwner(userId);\n    }\n\n    // Production Lines collection\n    match /productionLines/{lineId} {\n      // Admins can create, update, delete\n      allow write: if hasRole('admin');\n      // Any authenticated user can read production lines\n      allow read: if request.auth != null;\n    }\n\n    // Invites collection\n    match /invites/{inviteId} {\n        // Only admins can create invites (which triggers the Cloud Function)\n        allow create: if hasRole('admin');\n        // No one can read/update/delete directly, this is handled by the backend function\n        allow read, update, delete: if false;\n    }\n\n    // Issues collection\n    match /issues/{issueId} {\n      // Any authenticated user can create (report) an issue\n      allow create: if request.auth != null;\n\n      // Admins and supervisors can update issues\n      allow update: if hasRole('admin') || hasRole('supervisor');\n\n      // Any authenticated user can read issues\n      allow read: if request.auth != null;\n\n      // Only admins can delete issues (for data cleanup, etc.)\n      allow delete: if hasRole('admin');\n    }\n\n    // Stats collection (read-only for clients)\n    match /stats/{orgId} {\n        allow read: if hasRole('admin') || hasRole('supervisor');\n        allow write: if false; // Only backend functions can write to stats\n    }\n  }\n}\n",
  "functions": "const functions = require(\"firebase-functions/v2\");\nconst admin = require(\"firebase-admin\");\n\nadmin.initializeApp();\nconst db = admin.firestore();\n\n// Helper: increment stats safely\nasync function updateCounter(orgId, field, incrementBy) {\n  const ref = db.doc(`stats/${orgId}`);\n  await db.runTransaction(async (t) => {\n    const doc = await t.get(ref);\n    if (!doc.exists) {\n      // Initialize stats doc if missing\n      t.set(ref, { userCount: 0, lineCount: 0 }, { merge: true });\n    }\n    t.update(ref, {\n      [field]: admin.firestore.FieldValue.increment(incrementBy),\n    });\n  });\n}\n\n// ---------------- USERS ----------------\nexports.onUserCreate = functions.firestore\n  .document(\"users/{userId}\")\n  .onCreate(async (snap) => {\n    const data = snap.data();\n    if (data.orgId) {\n      await updateCounter(data.orgId, \"userCount\", 1);\n    }\n  });\n\nexports.onUserDelete = functions.firestore\n  .document(\"users/{userId}\")\n  .onDelete(async (snap) => {\n    const data = snap.data();\n    if (data.orgId) {\n      await updateCounter(data.orgId, \"userCount\", -1);\n    }\n  });\n\n// ---------------- PRODUCTION LINES ----------------\nexports.onLineCreate = functions.firestore\n  .document(\"productionLines/{lineId}\")\n  .onCreate(async (snap) => {\n    const data = snap.data();\n    if (data.orgId) {\n      await updateCounter(data.orgId, \"lineCount\", 1);\n    }\n  });\n\nexports.onLineDelete = functions.firestore\n  .document(\"productionLines/{lineId}\")\n  .onDelete(async (snap) => {\n    const data = snap.data();\n    if (data.orgId) {\n      await updateCounter(data.orgId, \"lineCount\", -1);\n    }\n  });\n\n\n// ---------------- USER INVITATIONS ----------------\n\n// Function to generate a random password\nfunction generatePassword() {\n  return Math.random().toString(36).slice(-8);\n}\n\n// This function triggers when a new document is added to the 'invites' collection.\n// It creates a new user in Firebase Authentication and then creates their user profile in Firestore.\nexports.processInvite = functions.firestore\n  .document(\"invites/{inviteId}\")\n  .onCreate(async (snap, context) => {\n    const inviteData = snap.data();\n\n    try {\n        // 1. Create the user in Firebase Auth\n        const userRecord = await admin.auth().createUser({\n            email: inviteData.email,\n            password: generatePassword(), // Temporary password\n            displayName: `${inviteData.firstName} ${inviteData.lastName}`,\n        });\n\n        // 2. Create the user document in Firestore\n        await db.collection(\"users\").doc(userRecord.uid).set({\n            firstName: inviteData.firstName,\n            lastName: inviteData.lastName,\n            email: inviteData.email,\n            role: inviteData.role,\n            plan: inviteData.plan,\n            orgId: inviteData.orgId,\n        });\n\n        // 3. Set custom claims for role-based access control\n        await admin.auth().setCustomUserClaims(userRecord.uid, { role: inviteData.role });\n\n        // 4. Send a password reset email, which acts as the invitation\n        const link = await admin.auth().generatePasswordResetLink(inviteData.email);\n        // (In a real app, you would use a transactional email service like SendGrid or Mailgun here)\n        console.log(`Password reset link for ${inviteData.email}: ${link}`);\n\n        // 5. Clean up the processed invite\n        await snap.ref.delete();\n\n        console.log(`Successfully invited and created user: ${inviteData.email}`);\n\n    } catch (error) {\n        console.error(\"Error processing invite:\", error);\n        // Optional: Update the invite doc with an error status\n        await snap.ref.update({ error: error.message });\n    }\n});\n"
}
