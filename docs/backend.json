
{
  "entities": {
    "Issue": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Issue",
      "type": "object",
      "description": "Represents an issue reported on the production line.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the issue."
        },
        "description": {
          "type": "string",
          "description": "Detailed description of the issue."
        },
        "location": {
          "type": "string",
          "description": "Location of the issue on the production line."
        },
        "severity": {
          "type": "string",
          "description": "Severity level of the issue (e.g., low, medium, high)."
        },
        "priority": {
          "type": "string",
          "description": "Priority level of the issue as determined by AI."
        },
        "status": {
          "type": "string",
          "description": "Current status of the issue (e.g., reported, in progress, resolved)."
        },
        "reportedBy": {
          "type": "string",
          "description": "Reference to User who reported the issue. (Relationship: User 1:N Issue)"
        },
        "assignedTo": {
          "type": "string",
          "description": "Reference to User assigned to resolve the issue. (Relationship: User 1:N Issue)"
        },
        "facilityKeyword": {
          "type": "string",
          "description": "Reference to FacilityKeyword. (Relationship: FacilityKeyword 1:N Issue)"
        },
        "reportedDate": {
          "type": "string",
          "description": "The date and time the issue was reported.",
          "format": "date-time"
        }
      },
      "required": [
        "id",
        "description",
        "location",
        "severity",
        "status",
        "reportedBy",
        "facilityKeyword",
        "reportedDate"
      ]
    },
    "User": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "User",
      "type": "object",
      "description": "Represents a user of the application.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the user."
        },
        "firstName": {
          "type": "string",
          "description": "First name of the user."
        },
        "lastName": {
          "type": "string",
          "description": "Last name of the user."
        },
        "email": {
          "type": "string",
          "description": "Email address of the user.",
          "format": "email"
        },
        "role": {
          "type": "string",
          "description": "Role of the user (e.g., operator, supervisor, admin)."
        },
        "address": {
          "type": "string",
          "description": "Home address of the user."
        },
        "country": {
          "type": "string",
          "description": "Country of the user."
        },
        "phone": {
          "type": "string",
          "description": "Phone number of the user."
        }
      },
      "required": [
        "id",
        "firstName",
        "lastName",
        "email",
        "role",
        "address",
        "country"
      ]
    },
    "FacilityKeyword": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "FacilityKeyword",
      "type": "object",
      "description": "Represents a keyword relevant to a specific facility.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the facility keyword."
        },
        "keyword": {
          "type": "string",
          "description": "The facility-relevant keyword."
        }
      },
      "required": [
        "id",
        "keyword"
      ]
    },
    "ProductionLine": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "ProductionLine",
      "type": "object",
      "description": "Represents a production line in the factory.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the production line."
        },
        "name": {
          "type": "string",
          "description": "The name of the production line."
        },
        "workstations": {
          "type": "array",
          "description": "A list of workstation names on this line.",
          "items": {
            "type": "string"
          }
        }
      },
      "required": [
        "id",
        "name",
        "workstations"
      ]
    }
  },
  "auth": {
    "providers": [
      "password",
      "anonymous",
      "google.com",
      "microsoft.com"
    ]
  },
  "firestore": {
    "rules": "rules_version = '2';\n\nservice cloud.firestore {\n  match /databases/{database}/documents {\n\n    // Helper Functions\n    function isSignedIn() {\n      return request.auth != null;\n    }\n\n    function isOwner(userId) {\n      return request.auth.uid == userId;\n    }\n\n    function getUserRole(userId) {\n      return get(/databases/$(database)/documents/users/$(userId)).data.role;\n    }\n\n    function isAdmin() {\n      return isSignedIn() && getUserRole(request.auth.uid) == 'admin';\n    }\n\n    function isSupervisor() {\n      return isSignedIn() && (getUserRole(request.auth.uid) == 'supervisor' || isAdmin());\n    }\n    \n    function isOperator() {\n        return isSignedIn() && getUserRole(request.auth.uid) == 'operator';\n    }\n\n    function isSameOrg(newUserEmail) {\n      let adminEmail = get(/databases/$(database)/documents/users/$(request.auth.uid)).data.email;\n      let adminDomain = adminEmail.split('@')[1];\n      let newUserDomain = newUserEmail.split('@')[1];\n      return adminDomain == newUserDomain;\n    }\n\n    // Collection: users\n    // - Admins can read and write any user document.\n    // - Any authenticated user can read their own document.\n    // - Only admins can create or delete users.\n    match /users/{userId} {\n      allow read: if isAdmin() || isOwner(userId);\n      allow write: if isAdmin();\n      allow create: if isAdmin() && isSameOrg(request.resource.data.email);\n      allow delete: if isAdmin();\n    }\n\n    // Collection: issues\n    // - Admins and Supervisors can read all issues.\n    // - Operators can read issues on their assigned production line.\n    // - Authenticated users can create new issues.\n    // - Admins and Supervisors can update issues.\n    match /issues/{issueId} {\n      allow read: if isSupervisor() || (isOperator() && resource.data.productionLineId == get(/databases/$(database)/documents/users/$(request.auth.uid)).data.productionLineId);\n      allow create: if isSignedIn();\n      allow update: if isSupervisor();\n      allow delete: if isAdmin();\n    }\n\n    // Collection: productionLines\n    // - All authenticated users can read production line data (needed for issue reporting).\n    // - Only Admins can create, update, or delete production lines.\n    match /productionLines/{lineId} {\n      allow read: if isSignedIn();\n      allow write: if isAdmin();\n      allow create: if isAdmin();\n      allow delete: if isAdmin();\n    }\n  }\n}",
    "structure": [
      {
        "path": "/users/{userId}",
        "definition": {
          "entityName": "User",
          "schema": {
            "$ref": "#/backend/entities/User"
          },
          "description": "Stores user profiles. User ID is used for authentication.",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier for the user."
            }
          ]
        }
      },
      {
        "path": "/issues/{issueId}",
        "definition": {
          "entityName": "Issue",
          "schema": {
            "$ref": "#/backend/entities/Issue"
          },
          "description": "Stores all reported issues in a single collection for easy querying and analysis.",
          "params": [
            {
              "name": "issueId",
              "description": "The unique identifier for the issue."
            }
          ]
        }
      },
      {
        "path": "/productionLines/{lineId}",
        "definition": {
          "entityName": "ProductionLine",
          "schema": {
            "$ref": "#/backend/entities/ProductionLine"
          },
          "description": "Stores all production lines in a single collection.",
          "params": [
            {
              "name": "lineId",
              "description": "The unique identifier for the production line."
            }
          ]
        }
      }
    ],
    "reasoning": "The Firestore structure uses top-level collections for Users, Issues, and ProductionLines. This flat structure simplifies queries, as all data for a given type is in one place. Security rules will be used to control access. For example, while all issues are in one collection, rules will ensure that only authorized users (like admins or supervisors) can view all issues, while operators might only see issues they reported."
  }
}

    