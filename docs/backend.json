
{
  "rules": "rules_version = '2';\n\nservice cloud.firestore {\n  match /databases/{database}/documents {\n\n    // This rule allows anyone with your Firestore database reference to view, edit,\n    // and delete all data in your Firestore database. It is useful for getting\n    // started, but it is configured to expire after 30 days because it\n    // leaves your app open to attackers. At that time, all client\n    // requests to your Firestore database will be denied.\n    //\n    // Make sure to write security rules for your app before that time, or else\n    // all client requests to your Firestore database will be denied until you Update\n    // your rules\n    match /{document=**} {\n      allow read, write: if request.time < timestamp.date(2025, 10, 31);\n    }\n  }\n}\n",
  "functions": "const functions = require(\"firebase-functions/v2\");\nconst admin = require(\"firebase-admin\");\n\nadmin.initializeApp();\nconst db = admin.firestore();\n\n// Helper: increment stats safely\nasync function updateCounter(orgId, field, incrementBy) {\n  const ref = db.doc(`stats/${orgId}`);\n  await db.runTransaction(async (t) => {\n    const doc = await t.get(ref);\n    if (!doc.exists) {\n      // Initialize stats doc if missing\n      t.set(ref, { userCount: 0, lineCount: 0 }, { merge: true });\n    }\n    t.update(ref, {\n      [field]: admin.firestore.FieldValue.increment(incrementBy),\n    });\n  });\n}\n\n// ---------------- USERS ----------------\nexports.onUserCreate = functions.firestore\n  .document(\"users/{userId}\")\n  .onCreate(async (snap) => {\n    const data = snap.data();\n    if (data.orgId) {\n      await updateCounter(data.orgId, \"userCount\", 1);\n    }\n  });\n\nexports.onUserDelete = functions.firestore\n  .document(\"users/{userId}\")\n  .onDelete(async (snap) => {\n    const data = snap.data();\n    if (data.orgId) {\n      await updateCounter(data.orgId, \"userCount\", -1);\n    }\n  });\n\n// ---------------- PRODUCTION LINES ----------------\nexports.onLineCreate = functions.firestore\n  .document(\"productionLines/{lineId}\")\n  .onCreate(async (snap) => {\n    const data = snap.data();\n    if (data.orgId) {\n      await updateCounter(data.orgId, \"lineCount\", 1);\n    }\n  });\n\nexports.onLineDelete = functions.firestore\n  .document(\"productionLines/{lineId}\")\n  .onDelete(async (snap) => {\n    const data = snap.data();\n    if (data.orgId) {\n      await updateCounter(data.orgId, \"lineCount\", -1);\n    }\n  });\n\n\n// ---------------- USER INVITATIONS ----------------\n\n// Function to generate a random password\nfunction generatePassword() {\n  return Math.random().toString(36).slice(-8);\n}\n\n// This function triggers when a new document is added to the 'invites' collection.\n// It creates a new user in Firebase Authentication and then creates their user profile in Firestore.\nexports.processInvite = functions.firestore\n  .document(\"invites/{inviteId}\")\n  .onCreate(async (snap, context) => {\n    const inviteData = snap.data();\n\n    try {\n        // 1. Create the user in Firebase Auth\n        const userRecord = await admin.auth().createUser({\n            email: inviteData.email,\n            password: generatePassword(), // Temporary password\n            displayName: `${inviteData.firstName} ${inviteData.lastName}`,\n        });\n\n        // 2. Create the user document in Firestore\n        await db.collection(\"users\").doc(userRecord.uid).set({\n            firstName: inviteData.firstName,\n            lastName: inviteData.lastName,\n            email: inviteData.email,\n            role: inviteData.role,\n            plan: inviteData.plan,\n            orgId: inviteData.orgId,\n        });\n\n        // 3. Set custom claims for role-based access control\n        await admin.auth().setCustomUserClaims(userRecord.uid, { role: inviteData.role });\n\n        // 4. Send a password reset email, which acts as the invitation\n        const link = await admin.auth().generatePasswordResetLink(inviteData.email);\n        // (In a real app, you would use a transactional email service like SendGrid or Mailgun here)\n        console.log(`Password reset link for ${inviteData.email}: ${link}`);\n\n        // 5. Clean up the processed invite\n        await snap.ref.delete();\n\n        console.log(`Successfully invited and created user: ${inviteData.email}`);\n\n    } catch (error) {\n        console.error(\"Error processing invite:\", error);\n        // Optional: Update the invite doc with an error status\n        await snap.ref.update({ error: error.message });\n    }\n});\n"
}
