{
  "rules": "rules_version = '2';\n\nservice cloud.firestore {\n  match /databases/{database}/documents {\n\n    // Get the user's document for role and orgId checks\n    function getUserData() {\n      return get(/databases/$(database)/documents/users/$(request.auth.uid)).data;\n    }\n\n    // Check if the user belongs to the org of the resource they are accessing\n    function isMemberOfOrg(resourceOrgId) {\n      let userOrgId = getUserData().orgId;\n      return userOrgId == resourceOrgId;\n    }\n\n    // Check user's role\n    function hasRole(role) {\n      return getUserData().role == role;\n    }\n\n    // Check if user is owner of a specific doc\n    function isOwner(userId) {\n      return request.auth.uid == userId;\n    }\n\n    // Users collection rules\n    match /users/{userId} {\n      // An admin can manage any user within their own organization\n      allow write: if hasRole('admin') && isMemberOfOrg(resource.data.orgId);\n      // A user can read/write their own profile\n      allow read, update: if isOwner(userId);\n      // An admin or supervisor can read any user profile within their org\n      allow read: if (hasRole('admin') || hasRole('supervisor')) && isMemberOfOrg(resource.data.orgId);\n    }\n\n    // Production Lines collection rules\n    match /productionLines/{lineId} {\n      // Only admins can write to lines within their org\n      allow write: if hasRole('admin') && isMemberOfOrg(request.resource.data.orgId);\n      // Any authenticated user can read lines belonging to their own org\n      allow read: if request.auth != null && isMemberOfOrg(resource.data.orgId);\n    }\n\n    // Issues collection rules\n    match /issues/{issueId} {\n      // Any authenticated user can create an issue for their own org\n      allow create: if request.auth != null && isMemberOfOrg(request.resource.data.orgId);\n      // Admins and supervisors can update issues within their org\n      allow update: if (hasRole('admin') || hasRole('supervisor')) && isMemberOfOrg(resource.data.orgId);\n      // Any authenticated user can read issues within their org\n      allow read: if request.auth != null && isMemberOfOrg(resource.data.orgId);\n      // Admins can delete issues within their org\n      allow delete: if hasRole('admin') && isMemberOfOrg(resource.data.orgId);\n    }\n\n    // Invites collection (for creating users)\n    match /invites/{inviteId} {\n      // Only admins can create invites for their own org\n      allow create: if hasRole('admin') && isMemberOfOrg(request.resource.data.orgId);\n      // No one can read/update/delete directly, this is handled by backend\n      allow read, update, delete: if false;\n    }\n\all    // Stats collection\n    match /stats/{orgId} {\n      // Admins/Supervisors can read stats for their own org\n      allow read: if (hasRole('admin') || hasRole('supervisor')) && isMemberOfOrg(orgId);\n      // Only backend can write\n      allow write: if false;\n    }\n  }\n}\n",
  "functions": "const functions = require(\"firebase-functions/v2\");\nconst admin = require(\"firebase-admin\");\n\nadmin.initializeApp();\nconst db = admin.firestore();\n\n// Helper: increment stats safely\nasync function updateCounter(orgId, field, incrementBy) {\n  const ref = db.doc(`stats/${orgId}`);\n  await db.runTransaction(async (t) => {\n    const doc = await t.get(ref);\n    if (!doc.exists) {\n      // Initialize stats doc if missing\n      t.set(ref, { userCount: 0, lineCount: 0 }, { merge: true });\n    }\n    t.update(ref, {\n      [field]: admin.firestore.FieldValue.increment(incrementBy),\n    });\n  });\n}\n\n// ---------------- USERS ----------------\nexports.onUserCreate = functions.firestore\n  .document(\"users/{userId}\")\n  .onCreate(async (snap) => {\n    const data = snap.data();\n    if (data.orgId) {\n      await updateCounter(data.orgId, \"userCount\", 1);\n    }\n  });\n\nexports.onUserDelete = functions.firestore\n  .document(\"users/{userId}\")\n  .onDelete(async (snap) => {\n    const data = snap.data();\n    if (data.orgId) {\n      await updateCounter(data.orgId, \"userCount\", -1);\n    }\n  });\n\n// ---------------- PRODUCTION LINES ----------------\nexports.onLineCreate = functions.firestore\n  .document(\"productionLines/{lineId}\")\n  .onCreate(async (snap) => {\n    const data = snap.data();\n    if (data.orgId) {\n      await updateCounter(data.orgId, \"lineCount\", 1);\n    }\n  });\n\nexports.onLineDelete = functions.firestore\n  .document(\"productionLines/{lineId}\")\n  .onDelete(async (snap) => {\n    const data = snap.data();\n    if (data.orgId) {\n      await updateCounter(data.orgId, \"lineCount\", -1);\n    }\n  });\n\n\n// ---------------- USER INVITATIONS ----------------\n\n// Function to generate a random password\nfunction generatePassword() {\n  return Math.random().toString(36).slice(-8);\n}\n\n// This function triggers when a new document is added to the 'invites' collection.\n// It creates a new user in Firebase Authentication and then creates their user profile in Firestore.\nexports.processInvite = functions.firestore\n  .document(\"invites/{inviteId}\")\n  .onCreate(async (snap, context) => {\n    const inviteData = snap.data();\n\n    try {\n        // 1. Create the user in Firebase Auth\n        const userRecord = await admin.auth().createUser({\n            email: inviteData.email,\n            password: generatePassword(), // Temporary password\n            displayName: `${inviteData.firstName} ${inviteData.lastName}`,\n        });\n\n        // 2. Create the user document in Firestore\n        await db.collection(\"users\").doc(userRecord.uid).set({\n            firstName: inviteData.firstName,\n            lastName: inviteData.lastName,\n            email: inviteData.email,\n            role: inviteData.role,\n            plan: inviteData.plan,\n            orgId: inviteData.orgId,\n        });\n\n        // 3. Set custom claims for role-based access control\n        await admin.auth().setCustomUserClaims(userRecord.uid, { role: inviteData.role });\n\n        // 4. Send a password reset email, which acts as the invitation\n        const link = await admin.auth().generatePasswordResetLink(inviteData.email);\n        // (In a real app, you would use a transactional email service like SendGrid or Mailgun here)\n        console.log(`Password reset link for ${inviteData.email}: ${link}`);\n\n        // 5. Clean up the processed invite\n        await snap.ref.delete();\n\n        console.log(`Successfully invited and created user: ${inviteData.email}`);\n\n    } catch (error) {\n        console.error(\"Error processing invite:\", error);\n        // Optional: Update the invite doc with an error status\n        await snap.ref.update({ error: error.message });\n    }\n});\n"
}